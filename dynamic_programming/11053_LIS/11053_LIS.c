// 앞선 문제들과 마찬가지로 왼쪽부터 오른쪽으로 진행하면서
// 각 순번에 있는 숫자들을 증가하는 부분 수열의 한 부분으로 편입시킨다고 했을 때
// 가장 길게 만들 수 있는 값을 구해서 해당 숫자에 기록하는 방법을 사용할 수 있을 것 같다.

// 예를 들어 {10, 20, 10, 30, 20, 50}이라는 수열을 가정해보자
// 첫번째 10에서 이 숫자를 마지막으로 하는 가장 긴 증가하는 부분 수열을 구하면 그 길이는 1이다.

// 두번째 자리부터 20에서 가장 긴 증가하는 부분 수열의 길이(이하 LIS로 통일)을 구하려면, 다음의 방법을 생각할 수 있다.
// 20이 LIS의 마지막 숫자가 되려면 앞에 있는 숫자들 중 20보다 작은 숫자로 끝나는 부분 수열을 찾아야 한다.
// 그런 조건을 만족하는 숫자가 여러 가지 있을텐데 그 중에서 가장 길이가 긴 수열을 찾자.
// 그렇게 찾은 가장 긴 수열의 길이에 1을 더한 것이 20을 마지막 숫자로 하는 LIS의 길이가 되는 것이다.
// 이제 이를 20의 자리에 기록하고 뒤에서도 비슷한 방식으로 이어나가면 된다.

// 이를 위해 tab[1005], arr[1005]의 수열을 선언한다.
// arr[i]는 인풋으로 받은 i번째 숫자를 입력하고,
// tab[i]는 해당 숫자를 마지막 숫자로 하는 LIS의 길이를 입력한다

// 그 후 위의 로직을 통해 최대 숫자를 구해볼 것이다

// (궁금한 점)
// tab, arr로 나누지 않고 tab[2][1005]로 선언했던 경우에는
// (N >= 22에 대해)
// 백준에서는 시간초과
// wsl2 우분투에서는 segmentation fault
// 같은 우분투에서 gdb로 디버깅할 때는 문제없이 실행 가능
// 도대체 무슨 차이??

#include <stdio.h>


int tab[1005];
int arr[1005];

int main()
{
	int N;
	scanf("%d", &N);


	int final_max = 0;
	for (int i = 1; i <= N; i++)
	{
		scanf("%d", &arr[i]);

		int temp_max = 0;

		for (int j = 1; j < i; j++)
			if (arr[j] < arr[i] && tab[j] > temp_max)
				temp_max = tab[j];
		tab[i] = temp_max + 1;

		if (tab[i] > final_max)
			final_max = tab[i];
	}

	printf("%d\n", final_max);

	return (0);
}