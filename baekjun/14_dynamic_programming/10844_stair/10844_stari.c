// 자릿수가 N일 때 계단수는
// N-1일 때 계단수에서 계산할 수 계산할 수 있다.
// N-1일 때 9로 끝나는 계단수의 경우의 수에서는 뒷자리에 8을 붙이는 경우 한 가지 가능성만 존재하고
// N-1일 때 0으로 끝나는 계단수의 경우의 수에서는 뒷자리에 1을 붙이는 한 가지 가능성만 존재한다.
// 나머지 숫자로 끝나는 계단수의 경우에는 +1을 한 숫자를 뒤에 붙이거나 -1을 한 숫자를 뒤에 붙일 수 있으므로
// 두 가지 경우의 수가 존재한다.
// 따라서 f(N, i)을 N자리일때 i로 끝나는 계단수의 경우의 수라고 하면
// 1 <= i <= 8인 경우 f(N, i) == f(N - 1, i - 1) + f(N - 1, i + 1)
// i == 0인 경우 f(N, 0) == f(N - 1, 1)
// i == 9인 경우 f(N, 9) == f(N - 1, 8)
// 이를 이용하여 bottom up 방식으로 문제를 풀어보려 한다

#include <stdio.h>

int cases(int N)
{
	// memo[i][j]는 i자리이면서 j로 끝나는 계단수의 경우의 수
	int memo[N + 1][10];

	// 0으로 시작하는 계단수는 없다고 했으므로 memo[1][0]은 0
	memo[1][0] = 0;
	// 나머지는 모두 한 가지만 존재
	for (int i = 1; i <= 9; i++)
		memo[1][i] = 1;

	// 그 뒤부터는 처음에 서술한 점화식을 통해 계단수 계산
	for (int i = 2; i <= N; i++)
	{
		memo[i][0] = memo[i - 1][1] % 1000000000;
		memo[i][9] = memo[i - 1][8] % 1000000000;

		for (int j = 1; j <= 8; j++)
			memo[i][j] = (memo[i - 1][j - 1] + memo[i - 1][j + 1]) % 1000000000;
	}

	int sum = 0;
	for (int i = 0; i < 10; i++)
	{
		sum += memo[N][i];
		sum %= 1000000000;
	}
	return (sum);
}


int main()
{
	int N;
	scanf("%d", &N);



	printf("%d\n", cases(N));

	return 0;
}